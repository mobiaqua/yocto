From a89857f9b175cf773ef903370c09814bd6c7747b Mon Sep 17 00:00:00 2001
From: Jai Luthra <j-luthra@ti.com>
Date: Mon, 10 Mar 2025 15:42:27 +0530
Subject: [PATCH 072/181] PENDING: media: ti: j721e-csi2rx: Restore streams on
 system suspend/resume

On system suspend, terminate any active DMA transfers and signal subdev
(cadence bridge) to stop streaming. Restore back the subdev and restart
DMA transfer on resume, using the same buffers (if any) as before.

Signed-off-by: Jai Luthra <j-luthra@ti.com>
Signed-off-by: Rishikesh Donadkar <r-donadkar@ti.com>
---
 .../platform/ti/j721e-csi2rx/j721e-csi2rx.c   | 75 +++++++++++++++++--
 1 file changed, 68 insertions(+), 7 deletions(-)

diff --git a/drivers/media/platform/ti/j721e-csi2rx/j721e-csi2rx.c b/drivers/media/platform/ti/j721e-csi2rx/j721e-csi2rx.c
index b9e4101e2c0e..7d60801007b4 100644
--- a/drivers/media/platform/ti/j721e-csi2rx/j721e-csi2rx.c
+++ b/drivers/media/platform/ti/j721e-csi2rx/j721e-csi2rx.c
@@ -1469,28 +1469,89 @@ static int ti_csi2rx_init_ctx(struct ti_csi2rx_ctx *ctx)
 static int ti_csi2rx_suspend(struct device *dev)
 {
 	struct ti_csi2rx_dev *csi = dev_get_drvdata(dev);
-	int i;
+	enum ti_csi2rx_dma_state state;
+	struct ti_csi2rx_ctx *ctx;
+	struct ti_csi2rx_dma *dma;
+	unsigned long flags = 0;
+	int i, ret = 0;
+
+	/*
+	 * If device is running, assert the pixel reset to cleanly stop any
+	 * on-going streams before we suspend.
+	 */
+	writel(0, csi->shim + SHIM_CNTL);
 
 	for (i = 0; i < csi->num_ctx; i++) {
+		ctx = &csi->ctx[i];
+		dma = &ctx->dma;
+
+		spin_lock_irqsave(&dma->lock, flags);
+		state = dma->state;
+		spin_unlock_irqrestore(&dma->lock, flags);
+
+		if (state != TI_CSI2RX_DMA_STOPPED) {
+			/* Disable source */
+			ret = v4l2_subdev_disable_streams(&csi->subdev,
+							  TI_CSI2RX_PAD_FIRST_SOURCE + ctx->idx,
+							  BIT(0));
+			if (ret)
+				dev_err(csi->dev, "Failed to stop subdev stream\n");
+		}
+
 		/* Stop any on-going streams */
-		writel(0, csi->shim + SHIM_DMACNTX(csi->ctx[i].idx));
-	}
+		writel(0, csi->shim + SHIM_DMACNTX(ctx->idx));
 
-	/* Assert the pixel reset. */
-	writel(0, csi->shim + SHIM_CNTL);
+		/* Drain DMA */
+		ti_csi2rx_drain_dma(ctx);
 
-	return 0;
+		/* Terminate DMA */
+		ret = dmaengine_terminate_sync(ctx->dma.chan);
+		if (ret)
+			dev_err(csi->dev, "Failed to stop DMA\n");
+	}
+
+	return ret;
 }
 
 static int ti_csi2rx_resume(struct device *dev)
 {
 	struct ti_csi2rx_dev *csi = dev_get_drvdata(dev);
+	struct ti_csi2rx_ctx *ctx;
+	struct ti_csi2rx_dma *dma;
+	struct ti_csi2rx_buffer *buf;
+	unsigned long flags = 0;
 	unsigned int reg;
+	int i, ret = 0;
 
+	/* If device was in use before, restore all the running streams */
 	reg = SHIM_CNTL_PIX_RST;
 	writel(reg, csi->shim + SHIM_CNTL);
 
-	return 0;
+	for (i = 0; i < csi->num_ctx; i++) {
+		ctx = &csi->ctx[i];
+		dma = &ctx->dma;
+		spin_lock_irqsave(&dma->lock, flags);
+		if (dma->state != TI_CSI2RX_DMA_STOPPED) {
+			/* Re-submit all previously submitted buffers to DMA */
+			list_for_each_entry(buf, &ctx->dma.submitted, list) {
+				ti_csi2rx_start_dma(ctx, buf);
+			}
+			spin_unlock_irqrestore(&dma->lock, flags);
+
+			/* Restore stream config */
+			ti_csi2rx_setup_shim(ctx);
+
+			ret = v4l2_subdev_enable_streams(&csi->subdev,
+							 TI_CSI2RX_PAD_FIRST_SOURCE + ctx->idx,
+							 BIT(0));
+			if (ret)
+				dev_err(ctx->csi->dev, "Failed to start subdev\n");
+		} else {
+			spin_unlock_irqrestore(&dma->lock, flags);
+		}
+	}
+
+	return ret;
 }
 
 static const struct dev_pm_ops ti_csi2rx_pm_ops = {
-- 
2.49.0

