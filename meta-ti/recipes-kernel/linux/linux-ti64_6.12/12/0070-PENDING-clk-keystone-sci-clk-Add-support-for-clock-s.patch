From 7f4400dc31441df23627fad67f96af522b936207 Mon Sep 17 00:00:00 2001
From: Sebin Francis <sebin.francis@ti.com>
Date: Wed, 5 Nov 2025 11:26:19 +0530
Subject: [PATCH 070/102] PENDING: clk: keystone: sci-clk: Add support for
 clock ssc configuration

Add support for configuring a clock's spread spectrum modulation.

Signed-off-by: Sebin Francis <sebin.francis@ti.com>
---
 drivers/clk/keystone/sci-clk.c         | 22 ++++++++
 drivers/firmware/ti_sci.c              | 76 ++++++++++++++++++++++++++
 drivers/firmware/ti_sci.h              | 28 ++++++++++
 include/linux/soc/ti/ti_sci_protocol.h |  3 +
 4 files changed, 129 insertions(+)

diff --git a/drivers/clk/keystone/sci-clk.c b/drivers/clk/keystone/sci-clk.c
index c5894fc9395e..8dd484e5e34e 100644
--- a/drivers/clk/keystone/sci-clk.c
+++ b/drivers/clk/keystone/sci-clk.c
@@ -260,6 +260,27 @@ static int sci_clk_set_parent(struct clk_hw *hw, u8 index)
 					      index + 1 + clk->clk_id);
 }
 
+/**
+ * sci_clk_set_spread_spectrum - Set spread spectrum for a TI SCI clock
+ * @hw: clock to set parent for
+ * @ss_conf: spread spectrum configuration
+ *
+ * Sets the spread spectrum of a TI SCI clock. Return TI SCI protocol status.
+ */
+static int sci_clk_set_spread_spectrum(struct clk_hw *hw, const struct clk_spread_spectrum *ss_conf)
+{
+	struct sci_clk *clk = to_sci_clk(hw);
+
+	clk->cached_req = 0;
+
+	if (clk->provider->ops->set_spread_spectrum)
+		return clk->provider->ops->set_spread_spectrum(clk->provider->sci, clk->dev_id,
+					      clk->clk_id, ss_conf->modfreq_hz, ss_conf->spread_bp,
+					      (u8)ss_conf->method);
+
+	return 0;
+}
+
 static const struct clk_ops sci_clk_ops = {
 	.prepare = sci_clk_prepare,
 	.unprepare = sci_clk_unprepare,
@@ -269,6 +290,7 @@ static const struct clk_ops sci_clk_ops = {
 	.set_rate = sci_clk_set_rate,
 	.get_parent = sci_clk_get_parent,
 	.set_parent = sci_clk_set_parent,
+	.set_spread_spectrum = sci_clk_set_spread_spectrum,
 };
 
 /**
diff --git a/drivers/firmware/ti_sci.c b/drivers/firmware/ti_sci.c
index 41534daf5371..64b7000ebfd3 100644
--- a/drivers/firmware/ti_sci.c
+++ b/drivers/firmware/ti_sci.c
@@ -9,6 +9,7 @@
 #define pr_fmt(fmt) "%s: " fmt, __func__
 
 #include <linux/bitmap.h>
+#include <linux/clk-provider.h>
 #include <linux/cpu.h>
 #include <linux/debugfs.h>
 #include <linux/export.h>
@@ -1664,6 +1665,79 @@ static int ti_sci_cmd_clk_get_freq(const struct ti_sci_handle *handle,
 	return ret;
 }
 
+/**
+ * ti_sci_cmd_clk_set_ssc() - Set SSC configurations
+ * @handle:	pointer to TI SCI handle
+ * @dev_id:	Device identifier this request is for
+ * @clk_id:	Clock identifier for the device for this request.
+ *		Each device has it's own set of clock inputs. This indexes
+ *		which clock input to modify.
+ * @modfreq_hz:	The modulation frequency in Hz
+ * @mod_depth:	The modulation depth in "permyriad".
+ * @spread_type: Type of spread sprectum modulation.
+ *
+ * Return: 0 if all went well, else returns appropriate error value.
+ */
+static int ti_sci_cmd_clk_set_ssc(const struct ti_sci_handle *handle,
+				   u32 dev_id, u32 clk_id, u32 modfreq_hz,
+				   u32 mod_depth, u8 spread_type)
+{
+	struct ti_sci_info *info;
+	struct ti_sci_msg_req_set_clock_ssc *req;
+	struct ti_sci_msg_hdr *resp;
+	struct ti_sci_xfer *xfer;
+	struct device *dev;
+	int ret = 0;
+
+	if (IS_ERR(handle))
+		return PTR_ERR(handle);
+	if (!handle)
+		return -EINVAL;
+
+	/* mod_depth must be between 10 and 310 */
+	if (mod_depth > 310 || mod_depth < 10)
+		return -EINVAL;
+
+	info = handle_to_ti_sci_info(handle);
+	dev = info->dev;
+
+	xfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_SSC,
+				   TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,
+				   sizeof(*req), sizeof(*resp));
+	if (IS_ERR(xfer)) {
+		ret = PTR_ERR(xfer);
+		dev_err(dev, "Message alloc failed(%d)\n", ret);
+		return ret;
+	}
+
+	req = (struct ti_sci_msg_req_set_clock_ssc *)xfer->xfer_buf;
+	req->dev_id = dev_id;
+	req->clk_id = clk_id;
+	req->modfreq_hz = modfreq_hz;
+	req->mod_depth = mod_depth;
+	req->spread_type = spread_type;
+
+	if (spread_type == CLK_SPREAD_NO)
+		req->enable = false;
+	else
+		req->enable = true;
+
+	ret = ti_sci_do_xfer(info, xfer);
+	if (ret) {
+		dev_err(dev, "Mbox send fail %d\n", ret);
+		goto fail;
+	}
+
+	resp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;
+
+	ret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;
+
+fail:
+	ti_sci_put_one_xfer(&info->minfo, xfer);
+
+	return ret;
+}
+
 /**
  * ti_sci_cmd_prepare_sleep() - Prepare system for system suspend
  * @handle:		pointer to TI SCI handle
@@ -3255,6 +3329,8 @@ static void ti_sci_setup_ops(struct ti_sci_info *info)
 	cops->get_best_match_freq = ti_sci_cmd_clk_get_match_freq;
 	cops->set_freq = ti_sci_cmd_clk_set_freq;
 	cops->get_freq = ti_sci_cmd_clk_get_freq;
+	if (info->fw_caps & MSG_FLAG_CAPS_CLOCK_SSC)
+		cops->set_spread_spectrum = ti_sci_cmd_clk_set_ssc;
 
 	if (info->fw_caps & MSG_FLAG_CAPS_LPM_DM_MANAGED) {
 		pr_debug("detected DM managed LPM in fw_caps\n");
diff --git a/drivers/firmware/ti_sci.h b/drivers/firmware/ti_sci.h
index 6da13df05320..d6ec759ea8b7 100644
--- a/drivers/firmware/ti_sci.h
+++ b/drivers/firmware/ti_sci.h
@@ -32,6 +32,7 @@
 #define TI_SCI_MSG_SET_CLOCK_PARENT	0x0102
 #define TI_SCI_MSG_GET_CLOCK_PARENT	0x0103
 #define TI_SCI_MSG_GET_NUM_CLOCK_PARENTS 0x0104
+#define TI_SCI_MSG_SET_CLOCK_SSC        0x010a
 #define TI_SCI_MSG_SET_CLOCK_FREQ	0x010c
 #define TI_SCI_MSG_QUERY_CLOCK_FREQ	0x010d
 #define TI_SCI_MSG_GET_CLOCK_FREQ	0x010e
@@ -158,6 +159,7 @@ struct ti_sci_msg_resp_query_fw_caps {
 #define MSG_FLAG_CAPS_GENERIC		TI_SCI_MSG_FLAG(0)
 #define MSG_FLAG_CAPS_LPM_PARTIAL_IO	TI_SCI_MSG_FLAG(4)
 #define MSG_FLAG_CAPS_LPM_DM_MANAGED	TI_SCI_MSG_FLAG(5)
+#define MSG_FLAG_CAPS_CLOCK_SSC		TI_SCI_MSG_FLAG(10)
 #define MSG_MASK_CAPS_LPM		GENMASK_ULL(4, 1)
 	u64 fw_caps;
 } __packed;
@@ -575,6 +577,32 @@ struct ti_sci_msg_resp_get_clock_freq {
 	u64 freq_hz;
 } __packed;
 
+/**
+ * struct ti_sci_msg_req_set_clock_ssc - Request to setup a clock spread spectrum
+ * @hdr:	Generic Header
+ * @dev_id:	Device identifier this request is for
+ * @clk_id:	Clock identifier for the device for this request.
+ * @modfreq_hz: The desired modulation frequency in Hz.
+ * @mod_depth:  The target modulation depth in "permyriad". The modulation depth
+ *		refers to the maximum variation in frequency as a percentage of
+ *		the clock center frequency. The minimum modulation depth is 0.1%
+ *		and the maximum is 3.1%. Modulation depth can be adjusted in 0.1%
+ *		increments.
+ * @spread_type: The target spread type.
+ * @enable:		Enable or disable SSC.
+ *
+ * This message is used to enable/disable a clock's spread spectrum configurations
+ */
+struct ti_sci_msg_req_set_clock_ssc {
+	struct ti_sci_msg_hdr	hdr;
+	u32			dev_id;
+	u32			clk_id;
+	u32			modfreq_hz;
+	u32			mod_depth;
+	u8			spread_type;
+	u8			enable;
+} __packed;
+
 /**
  * struct tisci_msg_req_prepare_sleep - Request for TISCI_MSG_PREPARE_SLEEP.
  *
diff --git a/include/linux/soc/ti/ti_sci_protocol.h b/include/linux/soc/ti/ti_sci_protocol.h
index d5c00b2661a4..73b74f878b87 100644
--- a/include/linux/soc/ti/ti_sci_protocol.h
+++ b/include/linux/soc/ti/ti_sci_protocol.h
@@ -193,6 +193,9 @@ struct ti_sci_clk_ops {
 			u64 min_freq, u64 target_freq, u64 max_freq);
 	int (*get_freq)(const struct ti_sci_handle *handle, u32 did, u32 cid,
 			u64 *current_freq);
+	int (*set_spread_spectrum)(const struct ti_sci_handle *handle,
+				   u32 dev_id, u32 clk_id, u32 modfreq_hz,
+				   u32 mod_depth, u8 spread_type);
 };
 
 /* TISCI LPM IO isolation control values */
-- 
2.51.1

