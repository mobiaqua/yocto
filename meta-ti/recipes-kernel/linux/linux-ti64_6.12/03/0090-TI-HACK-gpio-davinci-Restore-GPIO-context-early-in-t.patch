From 8f629009d2e3975f9e5f441f4a0dc12d7120b5e4 Mon Sep 17 00:00:00 2001
From: Kendall Willis <k-willis@ti.com>
Date: Fri, 21 Feb 2025 16:02:00 -0600
Subject: [PATCH 090/154] TI: HACK: gpio: davinci: Restore GPIO context early
 in ti_sci_resume

Fixes bug where GPIO state would reset upon resume from low power. GPIO
state should be maintained through system suspend/resume. The bug stems
from disabling IO isolation which would reset the GPIO state. Fix is
calling GPIO resume before disabling IO isolation in ti_sci_resume.

Labeled as HACK because davinci_gpio_resume is exposed and is being called
within ti_sci_resume. A flag has been added to the davinci_gpio_controller
to track if it has already restored context in order to not restore context
twice when resuming. In the process of finding a better way to fix the bug
where each driver is independent of each other.

Signed-off-by: Kendall Willis <k-willis@ti.com>
Reviewed-by: Dhruva Gole <d-gole@ti.com>
Reviewed-by: Kevin Hilman <khilman@baylibre.com>
Tested-by: Kevin Hilman <khilman@baylibre.com>
---
 drivers/firmware/ti_sci.c   |  8 ++++++++
 drivers/gpio/gpio-davinci.c | 21 ++++++++++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/drivers/firmware/ti_sci.c b/drivers/firmware/ti_sci.c
index c17f49c0475a..5efe885a4a12 100644
--- a/drivers/firmware/ti_sci.c
+++ b/drivers/firmware/ti_sci.c
@@ -3716,15 +3716,23 @@ static int __maybe_unused ti_sci_suspend_noirq(struct device *dev)
 	return 0;
 }
 
+extern int davinci_gpio_resume_all_devices(void);
+
 static int __maybe_unused ti_sci_resume_noirq(struct device *dev)
 {
 	struct ti_sci_info *info = dev_get_drvdata(dev);
 	int ret = 0;
+	int err;
 	u32 source;
 	u64 time;
 	u8 pin;
 	u8 mode;
 
+	/* Resume GPIO before disabling isolation to maintain GPIO state */
+	err = davinci_gpio_resume_all_devices();
+	if (err)
+		return err;
+
 	ret = ti_sci_cmd_set_io_isolation(&info->handle, TISCI_MSG_VALUE_IO_DISABLE);
 	if (ret)
 		return ret;
diff --git a/drivers/gpio/gpio-davinci.c b/drivers/gpio/gpio-davinci.c
index 76b58c70b257..f2cc94c260cd 100644
--- a/drivers/gpio/gpio-davinci.c
+++ b/drivers/gpio/gpio-davinci.c
@@ -62,6 +62,7 @@ struct davinci_gpio_controller {
 	int			irqs[MAX_INT_PER_BANK];
 	struct davinci_gpio_regs context[MAX_REGS_BANKS];
 	u32			binten_context;
+	bool		needs_context_restore;
 };
 
 static inline u32 __gpio_mask(unsigned gpio)
@@ -79,6 +80,7 @@ static inline struct davinci_gpio_regs __iomem *irq2regs(struct irq_data *d)
 }
 
 static int davinci_gpio_irq_setup(struct platform_device *pdev);
+int davinci_gpio_resume_all_devices(void);
 
 /*--------------------------------------------------------------------------*/
 
@@ -221,6 +223,7 @@ static int davinci_gpio_probe(struct platform_device *pdev)
 	chips->chip.request = gpiochip_generic_request;
 	chips->chip.free = gpiochip_generic_free;
 #endif
+	chips->needs_context_restore = false;
 	spin_lock_init(&chips->lock);
 
 	chips->gpio_unbanked = gpio_unbanked;
@@ -632,6 +635,7 @@ static int davinci_gpio_suspend(struct device *dev)
 	u32 nbank = DIV_ROUND_UP(chips->chip.ngpio, 32);
 
 	davinci_gpio_save_context(chips, nbank);
+	chips->needs_context_restore = true;
 
 	return 0;
 }
@@ -641,7 +645,10 @@ static int davinci_gpio_resume(struct device *dev)
 	struct davinci_gpio_controller *chips = dev_get_drvdata(dev);
 	u32 nbank = DIV_ROUND_UP(chips->chip.ngpio, 32);
 
-	davinci_gpio_restore_context(chips, nbank);
+	if (chips->needs_context_restore) {
+		davinci_gpio_restore_context(chips, nbank);
+		chips->needs_context_restore = false;
+	}
 
 	return 0;
 }
@@ -666,6 +673,18 @@ static struct platform_driver davinci_gpio_driver = {
 	},
 };
 
+static int davinci_gpio_resume_wrapper(struct device *dev, void *unused)
+{
+	return davinci_gpio_resume(dev);
+}
+
+int davinci_gpio_resume_all_devices(void)
+{
+	return driver_for_each_device(&davinci_gpio_driver.driver, NULL,
+					NULL, davinci_gpio_resume_wrapper);
+}
+EXPORT_SYMBOL(davinci_gpio_resume_all_devices);
+
 /*
  * GPIO driver registration needs to be done before machine_init functions
  * access GPIO. Hence davinci_gpio_drv_reg() is a postcore_initcall.
-- 
2.49.0

