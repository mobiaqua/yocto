--- linux-4.19.197/arch/arm/mach-omap2/board-generic.c	2021-07-11 12:49:32.000000000 +0200
+++ linux-4.19.196/arch/arm/mach-omap2/board-generic.c	2021-06-30 15:18:40.000000000 +0200
@@ -330,7 +330,7 @@ DT_MACHINE_START(DRA74X_DT, "Generic DRA
 	.init_late	= dra7xx_init_late,
 	.init_irq	= omap_gic_of_init,
 	.init_machine	= omap_generic_init,
-	.init_time	= omap3_gptimer_timer_init,
+	.init_time	= omap5_realtime_timer_init,
 	.dt_compat	= dra74x_boards_compat,
 	.restart	= omap44xx_restart,
 MACHINE_END
@@ -353,7 +353,7 @@ DT_MACHINE_START(DRA72X_DT, "Generic DRA
 	.init_late	= dra7xx_init_late,
 	.init_irq	= omap_gic_of_init,
 	.init_machine	= omap_generic_init,
-	.init_time	= omap3_gptimer_timer_init,
+	.init_time	= omap5_realtime_timer_init,
 	.dt_compat	= dra72x_boards_compat,
 	.restart	= omap44xx_restart,
 MACHINE_END
--- linux-4.19.197/drivers/clk/ti/clk-7xx.c	2021-07-11 12:49:32.000000000 +0200
+++ linux-4.19.196/drivers/clk/ti/clk-7xx.c	2021-06-30 15:18:40.000000000 +0200
@@ -733,7 +733,6 @@ const struct omap_clkctrl_data dra7_clkc
 static struct ti_dt_clk dra7xx_clks[] = {
 	DT_CLK(NULL, "timer_32k_ck", "sys_32k_ck"),
 	DT_CLK(NULL, "sys_clkin_ck", "timer_sys_clk_div"),
-	DT_CLK(NULL, "timer_sys_ck", "timer_sys_clk_div"),
 	DT_CLK(NULL, "sys_clkin", "sys_clkin1"),
 	DT_CLK(NULL, "atl_dpll_clk_mux", "atl_cm:0000:24"),
 	DT_CLK(NULL, "atl_gfclk_mux", "atl_cm:0000:26"),
--- linux-4.19.197/arch/arm/boot/dts/dra7.dtsi	2021-07-11 12:49:32.000000000 +0200
+++ linux-4.19.196/arch/arm/boot/dts/dra7.dtsi	2021-06-30 15:18:40.000000000 +0200
@@ -48,7 +48,6 @@
 
 	timer {
 		compatible = "arm,armv7-timer";
-		status = "disabled";	/* See ARM architected timer wrap erratum i940 */
 		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
 			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
 			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
@@ -911,8 +910,6 @@
 			reg = <0x48032000 0x80>;
 			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "timer2";
-			clock-names = "fck";
-			clocks = <&l4per_clkctrl DRA7_TIMER2_CLKCTRL 24>;
 		};
 
 		timer3: timer@48034000 {
@@ -920,10 +917,6 @@
 			reg = <0x48034000 0x80>;
 			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "timer3";
-			clock-names = "fck";
-			clocks = <&l4per_clkctrl DRA7_TIMER3_CLKCTRL 24>;
-			assigned-clocks = <&l4per_clkctrl DRA7_TIMER3_CLKCTRL 24>;
-			assigned-clock-parents = <&timer_sys_clk_div>;
 		};
 
 		timer4: timer@48036000 {
@@ -931,10 +924,6 @@
 			reg = <0x48036000 0x80>;
 			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
 			ti,hwmods = "timer4";
-			clock-names = "fck";
-			clocks = <&l4per_clkctrl DRA7_TIMER4_CLKCTRL 24>;
-			assigned-clocks = <&l4per_clkctrl DRA7_TIMER4_CLKCTRL 24>;
-			assigned-clock-parents = <&timer_sys_clk_div>;
 		};
 
 		timer5: timer@48820000 {
--- linux-4.19.197/arch/arm/mach-omap2/timer.c	2021-07-11 12:49:32.000000000 +0200
+++ linux-4.19.196/arch/arm/mach-omap2/timer.c	2021-06-30 15:18:40.000000000 +0200
@@ -42,7 +42,6 @@
 #include <linux/platform_device.h>
 #include <linux/platform_data/dmtimer-omap.h>
 #include <linux/sched_clock.h>
-#include <linux/cpu.h>
 
 #include <asm/mach/time.h>
 #include <asm/smp_twd.h>
@@ -65,28 +64,15 @@
 
 /* Clockevent code */
 
+static struct omap_dm_timer clkev;
+static struct clock_event_device clockevent_gpt;
+
 /* Clockevent hwmod for am335x and am437x suspend */
 static struct omap_hwmod *clockevent_gpt_hwmod;
 
 /* Clockesource hwmod for am437x suspend */
 static struct omap_hwmod *clocksource_gpt_hwmod;
 
-struct dmtimer_clockevent {
-	struct clock_event_device dev;
-	struct omap_dm_timer timer;
-};
-
-static struct dmtimer_clockevent clockevent;
-
-static struct omap_dm_timer *to_dmtimer(struct clock_event_device *clockevent)
-{
-	struct dmtimer_clockevent *clkevt =
-		container_of(clockevent, struct dmtimer_clockevent, dev);
-	struct omap_dm_timer *timer = &clkevt->timer;
-
-	return timer;
-}
-
 #ifdef CONFIG_SOC_HAS_REALTIME_COUNTER
 static unsigned long arch_timer_freq;
 
@@ -98,21 +84,24 @@ void set_cntfreq(void)
 
 static irqreturn_t omap2_gp_timer_interrupt(int irq, void *dev_id)
 {
-	struct dmtimer_clockevent *clkevt = dev_id;
-	struct clock_event_device *evt = &clkevt->dev;
-	struct omap_dm_timer *timer = &clkevt->timer;
+	struct clock_event_device *evt = &clockevent_gpt;
+
+	__omap_dm_timer_write_status(&clkev, OMAP_TIMER_INT_OVERFLOW);
 
-	__omap_dm_timer_write_status(timer, OMAP_TIMER_INT_OVERFLOW);
 	evt->event_handler(evt);
 	return IRQ_HANDLED;
 }
 
+static struct irqaction omap2_gp_timer_irq = {
+	.name		= "gp_timer",
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= omap2_gp_timer_interrupt,
+};
+
 static int omap2_gp_timer_set_next_event(unsigned long cycles,
 					 struct clock_event_device *evt)
 {
-	struct omap_dm_timer *timer = to_dmtimer(evt);
-
-	__omap_dm_timer_load_start(timer, OMAP_TIMER_CTRL_ST,
+	__omap_dm_timer_load_start(&clkev, OMAP_TIMER_CTRL_ST,
 				   0xffffffff - cycles, OMAP_TIMER_POSTED);
 
 	return 0;
@@ -120,26 +109,22 @@ static int omap2_gp_timer_set_next_event
 
 static int omap2_gp_timer_shutdown(struct clock_event_device *evt)
 {
-	struct omap_dm_timer *timer = to_dmtimer(evt);
-
-	__omap_dm_timer_stop(timer, OMAP_TIMER_POSTED, timer->rate);
-
+	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
 	return 0;
 }
 
 static int omap2_gp_timer_set_periodic(struct clock_event_device *evt)
 {
-	struct omap_dm_timer *timer = to_dmtimer(evt);
 	u32 period;
 
-	__omap_dm_timer_stop(timer, OMAP_TIMER_POSTED, timer->rate);
+	__omap_dm_timer_stop(&clkev, OMAP_TIMER_POSTED, clkev.rate);
 
-	period = timer->rate / HZ;
+	period = clkev.rate / HZ;
 	period -= 1;
 	/* Looks like we need to first set the load value separately */
-	__omap_dm_timer_write(timer, OMAP_TIMER_LOAD_REG, 0xffffffff - period,
+	__omap_dm_timer_write(&clkev, OMAP_TIMER_LOAD_REG, 0xffffffff - period,
 			      OMAP_TIMER_POSTED);
-	__omap_dm_timer_load_start(timer,
+	__omap_dm_timer_load_start(&clkev,
 				   OMAP_TIMER_CTRL_AR | OMAP_TIMER_CTRL_ST,
 				   0xffffffff - period, OMAP_TIMER_POSTED);
 	return 0;
@@ -153,17 +138,26 @@ static void omap_clkevt_idle(struct cloc
 	omap_hwmod_idle(clockevent_gpt_hwmod);
 }
 
-static void omap_clkevt_unidle(struct clock_event_device *evt)
+static void omap_clkevt_unidle(struct clock_event_device *unused)
 {
-	struct omap_dm_timer *timer = to_dmtimer(evt);
-
 	if (!clockevent_gpt_hwmod)
 		return;
 
 	omap_hwmod_enable(clockevent_gpt_hwmod);
-	__omap_dm_timer_int_enable(timer, OMAP_TIMER_INT_OVERFLOW);
+	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
 }
 
+static struct clock_event_device clockevent_gpt = {
+	.features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_FEAT_ONESHOT,
+	.rating			= 300,
+	.set_next_event		= omap2_gp_timer_set_next_event,
+	.set_state_shutdown	= omap2_gp_timer_shutdown,
+	.set_state_periodic	= omap2_gp_timer_set_periodic,
+	.set_state_oneshot	= omap2_gp_timer_shutdown,
+	.tick_resume		= omap2_gp_timer_shutdown,
+};
+
 static const struct of_device_id omap_timer_match[] __initconst = {
 	{ .compatible = "ti,omap2420-timer", },
 	{ .compatible = "ti,omap3430-timer", },
@@ -369,104 +363,47 @@ void tick_broadcast(const struct cpumask
 }
 #endif
 
-static void __init dmtimer_clkevt_init_common(struct dmtimer_clockevent *clkevt,
-					      int gptimer_id,
-					      const char *fck_source,
-					      unsigned int features,
-					      const struct cpumask *cpumask,
-					      const char *property,
-					      int rating, const char *name)
+static void __init omap2_gp_clockevent_init(int gptimer_id,
+						const char *fck_source,
+						const char *property)
 {
-	struct omap_dm_timer *timer = &clkevt->timer;
 	int res;
 
-	timer->id = gptimer_id;
-	timer->errata = omap_dm_timer_get_errata();
-	clkevt->dev.features = features;
-	clkevt->dev.rating = rating;
-	clkevt->dev.set_next_event = omap2_gp_timer_set_next_event;
-	clkevt->dev.set_state_shutdown = omap2_gp_timer_shutdown;
-	clkevt->dev.set_state_periodic = omap2_gp_timer_set_periodic;
-	clkevt->dev.set_state_oneshot = omap2_gp_timer_shutdown;
-	clkevt->dev.tick_resume = omap2_gp_timer_shutdown;
+	clkev.id = gptimer_id;
+	clkev.errata = omap_dm_timer_get_errata();
 
 	/*
 	 * For clock-event timers we never read the timer counter and
 	 * so we are not impacted by errata i103 and i767. Therefore,
 	 * we can safely ignore this errata for clock-event timers.
 	 */
-	__omap_dm_timer_override_errata(timer, OMAP_TIMER_ERRATA_I103_I767);
+	__omap_dm_timer_override_errata(&clkev, OMAP_TIMER_ERRATA_I103_I767);
 
-	res = omap_dm_timer_init_one(timer, fck_source, property,
-				     &clkevt->dev.name, OMAP_TIMER_POSTED);
+	res = omap_dm_timer_init_one(&clkev, fck_source, property,
+				     &clockevent_gpt.name, OMAP_TIMER_POSTED);
 	BUG_ON(res);
 
-	clkevt->dev.cpumask = cpumask;
-	clkevt->dev.irq = omap_dm_timer_get_irq(timer);
+	omap2_gp_timer_irq.dev_id = &clkev;
+	setup_irq(clkev.irq, &omap2_gp_timer_irq);
 
-	if (request_irq(clkevt->dev.irq, omap2_gp_timer_interrupt,
-			IRQF_TIMER | IRQF_IRQPOLL, name, clkevt))
-		pr_err("Failed to request irq %d (gp_timer)\n", clkevt->dev.irq);
+	__omap_dm_timer_int_enable(&clkev, OMAP_TIMER_INT_OVERFLOW);
 
-	__omap_dm_timer_int_enable(timer, OMAP_TIMER_INT_OVERFLOW);
+	clockevent_gpt.cpumask = cpu_possible_mask;
+	clockevent_gpt.irq = omap_dm_timer_get_irq(&clkev);
+	clockevents_config_and_register(&clockevent_gpt, clkev.rate,
+					3, /* Timer internal resynch latency */
+					0xffffffff);
 
 	if (soc_is_am33xx() || soc_is_am43xx()) {
-		clkevt->dev.suspend = omap_clkevt_idle;
-		clkevt->dev.resume = omap_clkevt_unidle;
+		clockevent_gpt.suspend = omap_clkevt_idle;
+		clockevent_gpt.resume = omap_clkevt_unidle;
 
 		clockevent_gpt_hwmod =
-			omap_hwmod_lookup(clkevt->dev.name);
+			omap_hwmod_lookup(clockevent_gpt.name);
 	}
 
-	pr_info("OMAP clockevent source: %s at %lu Hz\n", clkevt->dev.name,
-		timer->rate);
-}
-
-static DEFINE_PER_CPU(struct dmtimer_clockevent, dmtimer_percpu_timer);
-
-static int omap_gptimer_starting_cpu(unsigned int cpu)
-{
-	struct dmtimer_clockevent *clkevt = per_cpu_ptr(&dmtimer_percpu_timer, cpu);
-	struct clock_event_device *dev = &clkevt->dev;
-	struct omap_dm_timer *timer = &clkevt->timer;
-
-	clockevents_config_and_register(dev, timer->rate, 3, ULONG_MAX);
-	irq_force_affinity(dev->irq, cpumask_of(cpu));
-
-	return 0;
-}
-
-static int __init dmtimer_percpu_quirk_init(void)
-{
-	struct dmtimer_clockevent *clkevt;
-	struct clock_event_device *dev;
-	struct device_node *arm_timer;
-	struct omap_dm_timer *timer;
-	int cpu = 0;
-
-	arm_timer = of_find_compatible_node(NULL, NULL, "arm,armv7-timer");
-	if (of_device_is_available(arm_timer)) {
-		pr_warn_once("ARM architected timer wrap issue i940 detected\n");
-		return 0;
-	}
-
-	for_each_possible_cpu(cpu) {
-		clkevt = per_cpu_ptr(&dmtimer_percpu_timer, cpu);
-		dev = &clkevt->dev;
-		timer = &clkevt->timer;
-
-		dmtimer_clkevt_init_common(clkevt, 0, "timer_sys_ck",
-					   CLOCK_EVT_FEAT_ONESHOT,
-					   cpumask_of(cpu),
-					   "assigned-clock-parents",
-					   500, "percpu timer");
-	}
-
-	cpuhp_setup_state(CPUHP_AP_OMAP_DM_TIMER_STARTING,
-			  "clockevents/omap/gptimer:starting",
-			  omap_gptimer_starting_cpu, NULL);
-
-	return 0;
+	pr_info("OMAP clockevent source: %s at %lu Hz\n", clockevent_gpt.name,
+		clkev.rate);
 }
 
 /* Clocksource code */
@@ -606,15 +543,7 @@ static void __init __omap_sync32k_timer_
 {
 	omap_clk_init();
 	omap_dmtimer_init();
-	dmtimer_clkevt_init_common(&clockevent, clkev_nr, clkev_src,
-				   CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-				   cpu_possible_mask, clkev_prop, 300, "clockevent");
-	clockevents_config_and_register(&clockevent.dev, clockevent.timer.rate,
-					3, /* Timer internal resynch latency */
-					0xffffffff);
-
-	if (soc_is_dra7xx())
-		dmtimer_percpu_quirk_init();
+	omap2_gp_clockevent_init(clkev_nr, clkev_src, clkev_prop);
 
 	/* Enable the use of clocksource="gp_timer" kernel parameter */
 	if (use_gptimer_clksrc || gptimer)
@@ -643,7 +572,7 @@ void __init omap3_secure_sync32k_timer_i
 #endif /* CONFIG_ARCH_OMAP3 */
 
 #if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_SOC_AM33XX) || \
-	defined(CONFIG_SOC_AM43XX) || defined(CONFIG_SOC_DRA7XX)
+	defined(CONFIG_SOC_AM43XX)
 void __init omap3_gptimer_timer_init(void)
 {
 	__omap_sync32k_timer_init(2, "timer_sys_ck", NULL,
